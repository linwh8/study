# 操作系统

## 0 概述

### 宏观理解

> An Operating System is a program that manages the computer hardware,  providing a basis for application programs and acting as an intermediary between user and hardware  
> in Operating System Concepts, 7th Edition

![](https://i.loli.net/2018/06/01/5b10b017c5f70.png)

存储程序控制原理

1. 程序被转成二进制数存入存储器中（指令序列）
2. 运行时，CPU 从存储器中取出程序
3. CPU 逐条执行指令
4. 结果返回

所以 CPU 的主要作用是执行指令，按指令规定对数据进行操作

而操作系统的功能

1. **进程管理**。进程控制、进程同步、进程通信、死锁处理、处理机调度等。
2. **内存管理**。内存分配、地址映射、内存保护与共享、虚拟内存等。
3. **文件管理**。文件存储空间的管理、目录管理、文件读写管理和保护等。
4. **设备管理**。完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。主要包括缓冲管理、设备分配、设备处理、虛拟设备等

### 中断 interrupt

操作系统产生事件的基本操作就是中断。中断分成 3 类

1. 外中断 (hardware interrupts) 。由 CPU 执行指令以外的事件引起，如 I/O 结束中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。
2. 异常 (exception, software interrupts)。由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。
3. 陷入(trap, software interrupts)。在用户程序中使用系统调用。

### 双模式 dual mode

操作系统有两种模式，分为

- kernel mode 保护模式。需要 OS 服务的时候必须转到 kernel mode
- user mode 实模式。这个模式下用户程序受到限制

![](https://i.loli.net/2018/06/01/5b10b38049cc6.png)

## 1 进程

进程在内存中长这样

![](https://i.loli.net/2018/06/01/5b10b4a7ebb82.png)

进程是资源分配的基本单位。一个进程包括

- text，存放程序的二进制代码
- 栈 stack，编译时编译器计算并设定好，运行时由系统自动分配和释放。保存函数的参数值和返回地址，局部变量等，类似于数据结构中的栈
- 堆 heap，通常由程序员分配释放。若程序员不释放，程序结束时可能由OS回收 。与数据结构中的堆是两回事，可看成内存块的(链)表
- 数据段 data，全局区或静态区——存放全局变量和静态变量，通常是放在一块的，程序结束后由OS回收

### 进程控制块 PCB

进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。进程和 PCB 关系如下

![](https://i.loli.net/2018/06/01/5b10b6a3ce49a.png)

### 进程状态 state

进程状态切换如下

- 创建 new，建立 PCB 表格，分配资源
- 就绪状态 ready已经获得了除了 CPU 的资源，等待被调度
- 运行状态 running
- 阻塞状态 waiting，等待资源
- 停止 terminated

![](https://i.loli.net/2018/06/01/5b10b9fdbd6c5.png)

### 进程间通信 interprocess communication

- shared-memory 生产者消费者通信，用一个循环队列表示有限缓冲
- message-passing


## 2 线程 thread

线程是独立调度的基本单位。

一个进程中可以有多个线程，它们共享进程资源。线程共享**堆**，但是不共享**栈、寄存器**

### 线程和进程的区别 ⭐

- 拥有资源：**进程是资源分配的基本单位**，但是线程不拥有资源，线程可以访问隶属进程的资源
- 调度：**线程是独立调度的基本单位**，在同一进程中，线程的切换不会引起进程切换，从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换
- 系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小
- 通信方面：进程间通信 (IPC) 需要进程同步和互斥手段的辅助，以保证数据的一致性。而线程间可以通过直接读/写同一进程中的数据段（如全局变量）来进行通信

## 3 CPU 调度

### 调度算法

- first-come first-serverd 先来先服务。对长进程有利
- shortest job first 短进程优先。难在预测
- round robin 时间片轮转
- multilevel queue scheuling 多级队列

![](https://raw.githubusercontent.com/CyC2018/Interview-Notebook/master/pics/042cf928-3c8e-4815-ae9c-f2780202c68f.png)

## 4 进程同步

关键区问题：对共享数据得并发访问可能会导致数据不一致的问题，对这个问题的解决需要满足三个条件

1. 互斥
2. 前进（有空让进）
3. 有限等待

### 信号量 semaphores

- 大于 0 表示有 x 资源可用
- 小于 0 表示有 x 资源在等待
- 等于 0 表示没有资源可用

`wait()` 申请，`signal()` 释放

### 生产者消费者问题

问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。

因为缓冲区属于临界资源，因此需要使用一个互斥量 `mutex` 来控制对缓冲区的互斥访问。

为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：`empty` 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，`empty` 信号量是在生产者进程中使用，当 `empty` 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。

注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 `down(mutex)` 再执行 `down(empty)`。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 `down(empty)` 操作，发现 `empty = 0`，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，也就无法执行 `up(empty)` 操作，`empty` 永远都为 0，那么生产者和消费者就会一直等待下去，造成死锁

## 5 死锁

### 必要条件


- 互斥：每个资源要么已经分配给了一个进程，要么就是可用的。
- 占有和等待：已经得到了某个资源的进程可以再请求新的资源。
- 不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。
- 环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。

### 解决办法

1. 鸵鸟策略。忽视它
2. 死锁预防
    - 破坏互斥条件
    - 破坏占有和等待条件，所有进程在开始执行前请求所需要的全部资源
    - 破坏不可抢占条件
    - 破坏环路等待，给资源统一编号，进程只能按编号顺序来请求资源
3. 死锁避免，银行家算法

## 6 内存管理

### 虚拟内存


